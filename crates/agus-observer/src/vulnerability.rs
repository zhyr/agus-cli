use agus_ssh::{SshClient, SshError, SshTarget};
use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SoftwareVersion {
    pub name: String,
    pub version: String,
    pub source: String, // "dpkg", "rpm", "process", "docker"
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SystemVulnerabilityContext {
    pub os_info: String,
    pub kernel_version: String,
    pub installed_packages: Vec<SoftwareVersion>,
    pub running_processes: Vec<SoftwareVersion>,
    pub docker_images: Vec<SoftwareVersion>,
}

pub fn scan_vulnerability_context<C: SshClient>(
    client: &C,
    target: &SshTarget,
) -> Result<SystemVulnerabilityContext, SshError> {
    // 1. OS & Kernel Info
    let os_info = client
        .execute(
            target,
            "cat /etc/os-release | grep PRETTY_NAME | cut -d'=' -f2 | tr -d '\"'",
        )?
        .stdout
        .trim()
        .to_string();
    let kernel_version = client
        .execute(target, "uname -r")?
        .stdout
        .trim()
        .to_string();

    let mut installed_packages = Vec::new();

    // 2. Installed Packages (Debian/Ubuntu)
    if let Ok(res) = client.execute(
        target,
        "dpkg-query -W -f='${Package}|${Version}\n' 2>/dev/null | head -n 500",
    ) {
        for line in res.stdout.lines() {
            let parts: Vec<&str> = line.split('|').collect();
            if parts.len() == 2 {
                installed_packages.push(SoftwareVersion {
                    name: parts[0].to_string(),
                    version: parts[1].to_string(),
                    source: "dpkg".to_string(),
                });
            }
        }
    }

    // 2b. Installed Packages (CentOS/RHEL)
    if installed_packages.is_empty() {
        if let Ok(res) = client.execute(
            target,
            "rpm -qa --queryformat '%{NAME}|%{VERSION}-%{RELEASE}\n' | head -n 500",
        ) {
            for line in res.stdout.lines() {
                let parts: Vec<&str> = line.split('|').collect();
                if parts.len() == 2 {
                    installed_packages.push(SoftwareVersion {
                        name: parts[0].to_string(),
                        version: parts[1].to_string(),
                        source: "rpm".to_string(),
                    });
                }
            }
        }
    }

    // 3. Running Processes (Identifying common middleware versions)
    let mut running_processes = Vec::new();
    let proc_cmds = [
        ("nginx", "nginx -v 2>&1"),
        ("redis", "redis-server -v"),
        ("mysql", "mysql -V"),
        ("docker", "docker version --format '{{.Server.Version}}'"),
        ("ssh", "ssh -V 2>&1"),
    ];

    for (name, cmd) in proc_cmds {
        if let Ok(res) = client.execute(target, cmd) {
            running_processes.push(SoftwareVersion {
                name: name.to_string(),
                version: res.stdout.trim().to_string(),
                source: "process".to_string(),
            });
        }
    }

    // 4. Docker Images
    let mut docker_images = Vec::new();
    if let Ok(res) = client.execute(
        target,
        "docker images --format '{{.Repository}}|{{.Tag}}|{{.ID}}'",
    ) {
        for line in res.stdout.lines() {
            let parts: Vec<&str> = line.split('|').collect();
            if parts.len() >= 2 {
                docker_images.push(SoftwareVersion {
                    name: parts[0].to_string(),
                    version: parts[1].to_string(),
                    source: "docker".to_string(),
                });
            }
        }
    }

    Ok(SystemVulnerabilityContext {
        os_info,
        kernel_version,
        installed_packages,
        running_processes,
        docker_images,
    })
}
